#include "Board.h"

Board::Board(Pacman *pacman, std::array<Ghost, 4> *ghosts) :
	pacman(pacman),
	ghosts(ghosts),
	score(0)
{
	//initialize positions
	for (int i = 0; i < NUM_ROWS; i++) {
		for (int k = 0; k < NUM_COLS; k++) {
			board[i][k].set_pos({ i, k });
		}
	}

	init_board();
}

Board::~Board() {}

void Board::init_board() {
	std::array<std::array<int, NUM_COLS>, NUM_ROWS> cell_map = { {
		{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		{ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
		{ 1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1 },
		{ 1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1 },
		{ 1,3,1,0,0,1,2,1,0,0,0,1,2,1,1,2,1,0,0,0,1,2,1,0,0,1,3,1 },
		{ 1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1 },
		{ 1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1 },
		{ 1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1 },
		{ 1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1 },
		{ 1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1 },
		{ 1,1,1,1,1,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,1,1,1,1,1 },
		{ 0,0,0,0,0,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,0,0,0,0,0 },
		{ 0,0,0,0,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,0,0,0,0,0 },
		{ 0,0,0,0,0,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,0,0,0,0,0 },
		{ 1,1,1,1,1,1,2,1,1,0,1,0,0,0,0,0,0,1,0,1,1,2,1,1,1,1,1,1 },
		{ 0,0,0,0,0,0,2,0,0,0,1,0,0,0,0,0,0,1,0,0,0,2,0,0,0,0,0,0 },
		{ 1,1,1,1,1,1,2,1,1,0,1,0,0,0,0,0,0,1,0,1,1,2,1,1,1,1,1,1 },
		{ 0,0,0,0,0,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,0,0,0,0,0 },
		{ 0,0,0,0,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,0,0,0,0,0 },
		{ 0,0,0,0,0,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,0,0,0,0,0 },
		{ 1,1,1,1,1,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,1,1,1,1,1 },
		{ 1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1 },
		{ 1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1 },
		{ 1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1 },
		{ 1,3,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,3,1 },
		{ 1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1 },
		{ 1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1 },
		{ 1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1 },
		{ 1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1 },
		{ 1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1 },
		{ 1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1 },
		{ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },		
		{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }
	} };

	for (int i = 0; i < NUM_ROWS; i++) {
		for (int k = 0; k < NUM_COLS; k++) {
			board[i][k].set_state((Cell::State)cell_map[i][k]);
		}
	}
}

std::vector<Move> Board::get_moves(Cell origin) {
	Position pos = origin.get_pos();
	std::vector<Move> moves;
	
	if (!board[pos.x + 1][pos.y].state == Cell::State::WALL)
		moves.push_back({ 1, 0 });
	if (!board[pos.x - 1][pos.y].state == Cell::State::WALL)
		moves.push_back({ -1, 0 });
	if (!board[pos.x][pos.y + 1].state == Cell::State::WALL)
		moves.push_back({ 0, 1 });
	if (!board[pos.x][pos.y - 1].state == Cell::State::WALL)
		moves.push_back({ 0, -1 });

	return moves;
}

bool Board::update(Move move) {
	int x = pacman->get_pos().x;
	int y = pacman->get_pos().y;
	int newX = x + move.first;
	int newY = y + move.second;

	if (newX < 0 || newX > NUM_COLS - 1 ||
		newY < 0 || newY > NUM_ROWS - 1) {
		return false;
	}
	if (board[newX][newY].state == Cell::State::WALL) {
		return false;
	}
	//if ghost then die
	else {
		if (board[x][y].state == Cell::State::FOOD) {
			++score;
		}
		//TODO: if energizer return something special
		
		board[x][y].set_state(Cell::State::EMPTY);
		board[x][y].set_occupant(NULL);
		
		board[newX][newY].set_occupant(pacman);
		return true;
	}
}

void Board::draw(sf::RenderWindow *window) {
	for (int i = 0; i < NUM_ROWS; i++) {
		for (int k = 0; k < NUM_COLS; k++) {
			board[i][k].draw(window);
		}
	}
}